{"ast":null,"code":"import _defineProperty from \"C:/Users/mrhas/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"C:/Users/mrhas/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/mrhas/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _slicedToArray from \"C:/Users/mrhas/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _excluded = [\"scope\", \"children\"];\nimport $6vYhU$react from \"react\";\nimport { createContextScope as $6vYhU$createContextScope } from \"@radix-ui/react-context\";\nimport { useComposedRefs as $6vYhU$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Slot as $6vYhU$Slot } from \"@radix-ui/react-slot\";\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>…</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\nfunction $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {\n  /* -----------------------------------------------------------------------------------------------\n  * CollectionProvider\n  * ---------------------------------------------------------------------------------------------*/\n  var PROVIDER_NAME = name + 'CollectionProvider';\n  var _$6vYhU$createContext = $6vYhU$createContextScope(PROVIDER_NAME),\n    _$6vYhU$createContext2 = _slicedToArray(_$6vYhU$createContext, 2),\n    createCollectionContext = _$6vYhU$createContext2[0],\n    createCollectionScope = _$6vYhU$createContext2[1];\n  var _createCollectionCont = createCollectionContext(PROVIDER_NAME, {\n      collectionRef: {\n        current: null\n      },\n      itemMap: new Map()\n    }),\n    _createCollectionCont2 = _slicedToArray(_createCollectionCont, 2),\n    CollectionProviderImpl = _createCollectionCont2[0],\n    useCollectionContext = _createCollectionCont2[1];\n  var CollectionProvider = function CollectionProvider(props) {\n    var scope = props.scope,\n      children = props.children;\n    var ref = $6vYhU$react.useRef(null);\n    var itemMap = $6vYhU$react.useRef(new Map()).current;\n    return /*#__PURE__*/$6vYhU$react.createElement(CollectionProviderImpl, {\n      scope: scope,\n      itemMap: itemMap,\n      collectionRef: ref\n    }, children);\n  };\n  /*#__PURE__*/\n  Object.assign(CollectionProvider, {\n    displayName: PROVIDER_NAME\n  });\n  /* -----------------------------------------------------------------------------------------------\n  * CollectionSlot\n  * ---------------------------------------------------------------------------------------------*/\n  var COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n  var CollectionSlot = /*#__PURE__*/$6vYhU$react.forwardRef(function (props, forwardedRef) {\n    var scope = props.scope,\n      children = props.children;\n    var context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n    var composedRefs = $6vYhU$useComposedRefs(forwardedRef, context.collectionRef);\n    return /*#__PURE__*/$6vYhU$react.createElement($6vYhU$Slot, {\n      ref: composedRefs\n    }, children);\n  });\n  /*#__PURE__*/\n  Object.assign(CollectionSlot, {\n    displayName: COLLECTION_SLOT_NAME\n  });\n  /* -----------------------------------------------------------------------------------------------\n  * CollectionItem\n  * ---------------------------------------------------------------------------------------------*/\n  var ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  var ITEM_DATA_ATTR = 'data-radix-collection-item';\n  var CollectionItemSlot = /*#__PURE__*/$6vYhU$react.forwardRef(function (props, forwardedRef) {\n    var _$6vYhU$react$createE;\n    var scope = props.scope,\n      children = props.children,\n      itemData = _objectWithoutProperties(props, _excluded);\n    var ref = $6vYhU$react.useRef(null);\n    var composedRefs = $6vYhU$useComposedRefs(forwardedRef, ref);\n    var context = useCollectionContext(ITEM_SLOT_NAME, scope);\n    $6vYhU$react.useEffect(function () {\n      context.itemMap.set(ref, _objectSpread({\n        ref: ref\n      }, itemData));\n      return function () {\n        return void context.itemMap.delete(ref);\n      };\n    });\n    return /*#__PURE__*/$6vYhU$react.createElement($6vYhU$Slot, (_$6vYhU$react$createE = {}, _defineProperty(_$6vYhU$react$createE, ITEM_DATA_ATTR, ''), _defineProperty(_$6vYhU$react$createE, \"ref\", composedRefs), _$6vYhU$react$createE), children);\n  });\n  /*#__PURE__*/\n  Object.assign(CollectionItemSlot, {\n    displayName: ITEM_SLOT_NAME\n  });\n  /* -----------------------------------------------------------------------------------------------\n  * useCollection\n  * ---------------------------------------------------------------------------------------------*/\n  function useCollection(scope) {\n    var context = useCollectionContext(name + 'CollectionConsumer', scope);\n    var getItems = $6vYhU$react.useCallback(function () {\n      var collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      var orderedNodes = Array.from(collectionNode.querySelectorAll(\"[\".concat(ITEM_DATA_ATTR, \"]\")));\n      var items = Array.from(context.itemMap.values());\n      var orderedItems = items.sort(function (a, b) {\n        return orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current);\n      });\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n    return getItems;\n  }\n  return [{\n    Provider: CollectionProvider,\n    Slot: CollectionSlot,\n    ItemSlot: CollectionItemSlot\n  }, useCollection, createCollectionScope];\n}\nexport { $e02a7d9cb1dc128c$export$c74125a8e3af6bb2 as createCollection };","map":{"version":3,"mappings":";;;;;;;;;;AAaA;AACA;AACA;AACA;AAEA,SAASA,yCAAT,CAA0EC,IAA1E,EAAwF;EACtF;;;EAIA,IAAMC,aAAa,GAAGD,IAAI,GAAG,oBAA7B;EACA,4BAAyDE,yBAAkB,CAACD,aAAD,CAA3E;IAAA;IAAOE,uBAAD;IAA0BC,qBAA1B;EAON,4BAAuDD,uBAAuB,CAC5EF,aAD4E,EAE5E;MAAEI,aAAa,EAAE;QAAEC,OAAO,EAAE;OAA5B;MAAoCC,OAAO,EAAE,IAAIC,GAAJ;KAF+B,CAA9E;IAAA;IAAOC,sBAAD;IAAyBC,oBAAzB;EAKN,IAAMC,kBAAwE,GAAIC,SAA5ED,kBAAwE,CAAIC,KAAD,EAAW;IAC1F,IAAQC,KAAF,GAAsBD,KAA5B,CArCJC;MAqCmBC,WAAaF,KAA5B,CArCJE;IAsCI,IAAMC,GAAG,GAAGC,YAAK,CAACC,MAAN,CAAgC,IAAhC,CAAZ;IACA,IAAMV,OAAO,GAAGS,YAAK,CAACC,MAAN,CAAsC,IAAIT,GAAJ,EAAtC,EAAiDF,OAAjE;IACA,oBACEY,2BAACT,sBAAD,EADF;MAC0BI,KAAK,EAAEA,KAA/B;MAAsCN,OAAO,EAAEA,OAA/C;MAAwDF,aAAa,EAAEU;KAAvE,EACGD,QADH,CADF;GAJF;EAWA;EAAAK;IAAAC;GAAA;EAEA;;;EAIA,IAAMC,oBAAoB,GAAGrB,IAAI,GAAG,gBAApC;EAEA,IAAMsB,cAAc,gBAAGN,YAAK,CAACO,UAAN,CACrB,UAACX,KAAD,EAAQY,YAAR,EAAyB;IACvB,IAAQX,KAAF,GAAsBD,KAA5B,CAzDNC;MAyDqBC,WAAaF,KAA5B,CAzDNE;IA0DM,IAAMW,OAAO,GAAGf,oBAAoB,CAACW,oBAAD,EAAuBR,KAAvB,CAApC;IACA,IAAMa,YAAY,GAAGC,sBAAe,CAACH,YAAD,EAAeC,OAAO,CAACpB,aAAvB,CAApC;IACA,oBAAOa,2BAACU,WAAD,EAAP;MAAab,GAAG,EAAEW;KAAX,EAA0BZ,QAA1B,CAAP;GALmB,CAAvB;EASA;EAAAK;IAAAC;GAAA;EAEA;;;EAIA,IAAMS,cAAc,GAAG7B,IAAI,GAAG,oBAA9B;EACA,IAAM8B,cAAc,GAAG,4BAAvB;EAOA,IAAMC,kBAAkB,gBAAGf,YAAK,CAACO,UAAN,CACzB,UAACX,KAAD,EAAQY,YAAR,EAAyB;IAAA;IACvB,IAAQX,KAAF,GAAmCD,KAAzC,CAhFNC;MAgFqBC,QAAT,GAAmCF,KAAzC,CAhFNE;MAgFkCkB,QAAH,4BAAgBpB,KAAzC;IACA,IAAMG,GAAG,GAAGC,YAAK,CAACC,MAAN,CAA0B,IAA1B,CAAZ;IACA,IAAMS,YAAY,GAAGC,sBAAe,CAACH,YAAD,EAAeT,GAAf,CAApC;IACA,IAAMU,OAAO,GAAGf,oBAAoB,CAACmB,cAAD,EAAiBhB,KAAjB,CAApC;IAEAG,YAAK,CAACiB,SAAN,CAAgB,YAAM;MACpBR,OAAO,CAAClB,OAAR,CAAgB2B,GAAhB,CAAoBnB,GAApB;QAtFRA,KAsFmCA;MAAF,GAAWiB,QAAJ,EAAP;MACzB,OAAO;QAAA,OAAM,KAAKP,OAAO,CAAClB,OAAR,CAAgB4B,MAAhB,CAAuBpB,GAAvB,CAAlB;MAAA;KAFF,CAGC;IAED,oBACEG,2BAACU,WAAD,sEAAaE,cAAD,EAAkB,EAA9B,iDAAyCJ,YAAL,2BACjCZ,QADH,CADF;GAZuB,CAA3B;EAoBA;EAAAK;IAAAC;GAAA;EAEA;;;EAIA,SAASgB,aAAT,CAAuBvB,KAAvB,EAAmC;IACjC,IAAMY,OAAO,GAAGf,oBAAoB,CAACV,IAAI,GAAG,oBAAR,EAA8Ba,KAA9B,CAApC;IAEA,IAAMwB,QAAQ,GAAGrB,YAAK,CAACsB,WAAN,CAAkB,YAAM;MACvC,IAAMC,cAAc,GAAGd,OAAO,CAACpB,aAAR,CAAsBC,OAA7C;MACA,IAAI,CAACiC,cAAL,EAAqB,OAAO,EAAP;MACrB,IAAMC,YAAY,GAAGC,KAAK,CAACC,IAAN,CAAWH,cAAc,CAACI,gBAAf,YAAoCb,cAAe,OAA9D,CAArB;MACA,IAAMc,KAAK,GAAGH,KAAK,CAACC,IAAN,CAAWjB,OAAO,CAAClB,OAAR,CAAgBsC,MAAhB,EAAX,CAAd;MACA,IAAMC,YAAY,GAAGF,KAAK,CAACG,IAAN,CACnB,UAACC,CAAD,EAAIC,CAAJ;QAAA,OAAUT,YAAY,CAACU,OAAb,CAAqBF,CAAC,CAACjC,GAAF,CAAMT,OAA3B,IAAuCkC,YAAY,CAACU,OAAb,CAAqBD,CAAC,CAAClC,GAAF,CAAMT,OAA3B,CAD9B;MAAA,EAArB;MAGA,OAAOwC,YAAP;KARe,EASd,CAACrB,OAAO,CAACpB,aAAT,EAAwBoB,OAAO,CAAClB,OAAhC,CATc,CAAjB;IAWA,OAAO8B,QAAP;;EAGF,OAAO,CACL;IAAEc,QAAQ,EAAExC,kBAAZ;IAAgCyC,IAAI,EAAE9B,cAAtC;IAAsD+B,QAAQ,EAAEtB;GAD3D,EAELK,aAFK,EAGLhC,qBAHK,CAAP","names":["createCollection","name","PROVIDER_NAME","createContextScope","createCollectionContext","createCollectionScope","collectionRef","current","itemMap","Map","CollectionProviderImpl","useCollectionContext","CollectionProvider","props","scope","children","ref","React","useRef","$6vYhU$react","Object","displayName","COLLECTION_SLOT_NAME","CollectionSlot","forwardRef","forwardedRef","context","composedRefs","useComposedRefs","$6vYhU$Slot","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlot","itemData","useEffect","set","delete","useCollection","getItems","useCallback","collectionNode","orderedNodes","Array","from","querySelectorAll","items","values","orderedItems","sort","a","b","indexOf","Provider","Slot","ItemSlot"],"sources":["C:\\Users\\mrhas\\Desktop\\portfolio\\node_modules\\@radix-ui\\react-collection\\dist\\packages\\react\\collection\\src\\Collection.tsx"],"sourcesContent":["import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\ntype SlotProps = Radix.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>…</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <Slot ref={composedRefs}>{children}</Slot>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}